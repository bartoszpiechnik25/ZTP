// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: documents.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createDocument = `-- name: CreateDocument :exec
INSERT INTO documents (id, title, notes, document_type_id, document_category_id)
    VALUES ($1, $2, $3, $4, $5)
`

type CreateDocumentParams struct {
	ID                 uuid.UUID `json:"id"`
	Title              *string   `json:"title"`
	Notes              *string   `json:"notes"`
	DocumentTypeID     uuid.UUID `json:"document_type_id"`
	DocumentCategoryID uuid.UUID `json:"document_category_id"`
}

func (q *Queries) CreateDocument(ctx context.Context, arg CreateDocumentParams) error {
	_, err := q.db.Exec(ctx, createDocument,
		arg.ID,
		arg.Title,
		arg.Notes,
		arg.DocumentTypeID,
		arg.DocumentCategoryID,
	)
	return err
}

const createDocumentPage = `-- name: CreateDocumentPage :exec
INSERT INTO document_pages (id, page_number, content_type, data, ocr_content, document_id)
    VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateDocumentPageParams struct {
	ID          uuid.UUID `json:"id"`
	PageNumber  int16     `json:"page_number"`
	ContentType *string   `json:"content_type"`
	Data        []byte    `json:"data"`
	OcrContent  *string   `json:"ocr_content"`
	DocumentID  uuid.UUID `json:"document_id"`
}

func (q *Queries) CreateDocumentPage(ctx context.Context, arg CreateDocumentPageParams) error {
	_, err := q.db.Exec(ctx, createDocumentPage,
		arg.ID,
		arg.PageNumber,
		arg.ContentType,
		arg.Data,
		arg.OcrContent,
		arg.DocumentID,
	)
	return err
}

const createUserDocument = `-- name: CreateUserDocument :exec
INSERT INTO user_documents (user_id, document_id)
    VALUES ($1, $2)
`

type CreateUserDocumentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	DocumentID uuid.UUID `json:"document_id"`
}

func (q *Queries) CreateUserDocument(ctx context.Context, arg CreateUserDocumentParams) error {
	_, err := q.db.Exec(ctx, createUserDocument, arg.UserID, arg.DocumentID)
	return err
}

const deleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents
WHERE id = $1
`

func (q *Queries) DeleteDocument(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocument, id)
	return err
}

const deleteDocumentPages = `-- name: DeleteDocumentPages :exec
DELETE FROM document_pages
WHERE document_id = $1
`

func (q *Queries) DeleteDocumentPages(ctx context.Context, documentID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocumentPages, documentID)
	return err
}

const deleteUserDocument = `-- name: DeleteUserDocument :exec
DELETE FROM user_documents
WHERE user_id = $1 AND document_id = $2
`

type DeleteUserDocumentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	DocumentID uuid.UUID `json:"document_id"`
}

func (q *Queries) DeleteUserDocument(ctx context.Context, arg DeleteUserDocumentParams) error {
	_, err := q.db.Exec(ctx, deleteUserDocument, arg.UserID, arg.DocumentID)
	return err
}

const getAllUserDocuments = `-- name: GetAllUserDocuments :many
SELECT
    d.id,
    d.title,
    d.notes,
    dc.name AS category,
    dt.name AS type
FROM
    user_documents ud
    JOIN documents d ON d.id = ud.document_id
    JOIN document_categories dc ON dc.id = d.document_category_id
    JOIN document_types dt ON dt.id = d.document_type_id
WHERE
    ud.user_id = $1
`

type GetAllUserDocumentsRow struct {
	ID       uuid.UUID `json:"id"`
	Title    *string   `json:"title"`
	Notes    *string   `json:"notes"`
	Category string    `json:"category"`
	Type     string    `json:"type"`
}

func (q *Queries) GetAllUserDocuments(ctx context.Context, userID uuid.UUID) ([]GetAllUserDocumentsRow, error) {
	rows, err := q.db.Query(ctx, getAllUserDocuments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserDocumentsRow
	for rows.Next() {
		var i GetAllUserDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Notes,
			&i.Category,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentById = `-- name: GetDocumentById :one
SELECT
    d.id,
    d.title,
    d.notes,
    dc.name AS category,
    dt.name AS type
FROM
    documents d
    JOIN document_categories dc ON dc.id = d.document_category_id
    JOIN document_types dt ON dt.id = d.document_type_id
WHERE
    d.id = $1
`

type GetDocumentByIdRow struct {
	ID       uuid.UUID `json:"id"`
	Title    *string   `json:"title"`
	Notes    *string   `json:"notes"`
	Category string    `json:"category"`
	Type     string    `json:"type"`
}

func (q *Queries) GetDocumentById(ctx context.Context, id uuid.UUID) (GetDocumentByIdRow, error) {
	row := q.db.QueryRow(ctx, getDocumentById, id)
	var i GetDocumentByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Notes,
		&i.Category,
		&i.Type,
	)
	return i, err
}

const getDocumentCategories = `-- name: GetDocumentCategories :many
SELECT
    id, name
FROM
    document_categories
`

func (q *Queries) GetDocumentCategories(ctx context.Context) ([]DocumentCategory, error) {
	rows, err := q.db.Query(ctx, getDocumentCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentCategory
	for rows.Next() {
		var i DocumentCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentCategory = `-- name: GetDocumentCategory :one
SELECT
    id, name
FROM
    document_categories dc
WHERE
    dc.name = $1
`

func (q *Queries) GetDocumentCategory(ctx context.Context, name string) (DocumentCategory, error) {
	row := q.db.QueryRow(ctx, getDocumentCategory, name)
	var i DocumentCategory
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getDocumentPages = `-- name: GetDocumentPages :many
SELECT
    id,
    page_number,
    content_type,
    data,
    ocr_content,
    document_id
FROM
    document_pages
WHERE
    document_id = $1
ORDER BY
    page_number ASC
`

func (q *Queries) GetDocumentPages(ctx context.Context, documentID uuid.UUID) ([]DocumentPage, error) {
	rows, err := q.db.Query(ctx, getDocumentPages, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentPage
	for rows.Next() {
		var i DocumentPage
		if err := rows.Scan(
			&i.ID,
			&i.PageNumber,
			&i.ContentType,
			&i.Data,
			&i.OcrContent,
			&i.DocumentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentType = `-- name: GetDocumentType :one
SELECT
    id, name
FROM
    document_types dt
WHERE
    dt.name = $1
`

func (q *Queries) GetDocumentType(ctx context.Context, name string) (DocumentType, error) {
	row := q.db.QueryRow(ctx, getDocumentType, name)
	var i DocumentType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getDocumentTypes = `-- name: GetDocumentTypes :many
SELECT
    id, name
FROM
    document_types
`

func (q *Queries) GetDocumentTypes(ctx context.Context) ([]DocumentType, error) {
	rows, err := q.db.Query(ctx, getDocumentTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentType
	for rows.Next() {
		var i DocumentType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentWithPages = `-- name: GetDocumentWithPages :one
SELECT
    d.id,
    d.title,
    d.notes,
    dc.name AS category,
    dt.name AS type
FROM
    documents d
    JOIN document_categories dc ON dc.id = d.document_category_id
    JOIN document_types dt ON dt.id = d.document_type_id
WHERE
    d.id = $1
`

type GetDocumentWithPagesRow struct {
	ID       uuid.UUID `json:"id"`
	Title    *string   `json:"title"`
	Notes    *string   `json:"notes"`
	Category string    `json:"category"`
	Type     string    `json:"type"`
}

func (q *Queries) GetDocumentWithPages(ctx context.Context, id uuid.UUID) (GetDocumentWithPagesRow, error) {
	row := q.db.QueryRow(ctx, getDocumentWithPages, id)
	var i GetDocumentWithPagesRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Notes,
		&i.Category,
		&i.Type,
	)
	return i, err
}

const verifyUserOwnsDocument = `-- name: VerifyUserOwnsDocument :one
SELECT COUNT(*) > 0 AS owns_document
FROM user_documents
WHERE user_id = $1 AND document_id = $2
`

type VerifyUserOwnsDocumentParams struct {
	UserID     uuid.UUID `json:"user_id"`
	DocumentID uuid.UUID `json:"document_id"`
}

func (q *Queries) VerifyUserOwnsDocument(ctx context.Context, arg VerifyUserOwnsDocumentParams) (bool, error) {
	row := q.db.QueryRow(ctx, verifyUserOwnsDocument, arg.UserID, arg.DocumentID)
	var owns_document bool
	err := row.Scan(&owns_document)
	return owns_document, err
}
